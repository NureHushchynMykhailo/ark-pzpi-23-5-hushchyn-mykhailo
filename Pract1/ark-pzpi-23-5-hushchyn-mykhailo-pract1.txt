МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з практичного заняття №1 з дисципліни
аналіз та рефакторінг коду




Виконав:                                                                     Перевірив:
ст. гр. ПЗПІ-23-5                        			   ст. викладач кафедри ПІ
Гущин М.В.           		   Сокорчук Ігор Петрович


Харків 2025

ІСТОРІЯ ЗМІН
      №      ДатаВерсія звіту      Опис змін та виправлень      1      26.11.2025      0.1      Початкова версія


1 МЕТА РОБОТИ
     Сформувати розуміння важливості дотримання правил оформлення програмного коду та вивчити основні рекомендації написання коду для обраної мови програмування. Навчитися застосовувати принципи code convention з метою підвищення читабельності, структурованості та зрозумілості програмного забезпечення.
     2 ОПИС ВИКОНАНОЇ РОБОТИ
     Стандартизація коду є фундаментальним аспектом професійної розробки програмного забезпечення. Це не питання особистих уподобань, а ключовий інструмент комунікації в команді. Коли розробники дотримуються єдиного стилю, проєкт стає передбачуваним. Основні переваги дотримання стилю кодування включають: по-перше, значно покращену читабельність, що знижує когнітивне навантаження при аналізі чужого коду; по-друге, підтримуваність – чистий код легше модифікувати та розширювати; і по-третє, мінімізація помилок, оскільки неконсистентний стиль часто приховує логічні дефекти. У .NET MAUI, де переплітаються логіка C# та декларативна розмітка XAML, відсутність стандартів призводить до хаосу особливо швидко.
     Якісний код починається з організації файлів та логічного поділу. Для .NET MAUI базовим архітектурним шаблоном є MVVM (Model-View-ViewModel). Цей шаблон є головним принципом поділу коду.
     View (Представлення) – це XAML-розмітка. Вона має бути максимально декларативною і не містити бізнес-логіки. Файли code-behind (наприклад, MainPage.xaml.cs) повинні бути майже порожніми, ідеально – містити лише виклик InitializeComponent().
     ViewModel (Модель представлення) – це клас C#, що містить всю логіку стану та поведінки для View. Він надає дані через публічні властивості та дії через команди (ICommand).
     Model (Модель) – це класи C#, що описують бізнес-об'єкти та дані. Такий поділ забезпечує чітку структуру та можливість тестування.
Логічний поділ проєкту на папки (Views, ViewModels, Models, Services) є першим кроком до чистої структури.
     Візуальне форматування є фундаментом читабельності коду. Це перше, що сприймає розробник, і від цього залежить, наскільки швидко він зможе зрозуміти логічну структуру програми. Два ключові елементи тут — це відступи та стиль розстановки дужок.
     Відступи (Indentation): У C# та в цілому в екосистемі .NET абсолютним стандартом є використання чотирьох пробілів для одного рівня вкладеності. Категорично не рекомендується використовувати символи табуляції. Причина проста: різні редактори коду та системи контролю версій (як Git) можуть відображати табуляцію з різною шириною (2, 4, або навіть 8 пробілів). Це призводить до "поламаного" форматування, коли код, що ідеально виглядав у одного розробника, стає хаотичним у іншого. Використання 4 пробілів гарантує, що візуальна структура коду буде ідентичною на будь-якому комп'ютері.
     Стиль дужок (Brace Style): Для C# рекомендованим і найбільш поширеним є стиль Allman. Його головна риса: кожна фігурна дужка, що відкриває ({) або закриває (}) логічний блок, розміщується на новому, окремому рядку і на тому ж рівні відступу, що й батьківська конструкція (клас, метод, умова if). Перевага: Цей стиль створює чітке візуальне розмежування логічних блоків. Легко побачити, де починається і де закінчується метод чи тіло циклу, оскільки дужки вертикально вирівняні.
     У прикладі поганого коду (рядки 1-7) використовується стиль K&R (де відкриваюча дужка на тому ж рядку), що є нормою, наприклад, в Java, але не в C#. Гірше того, стиль неконсистентний. Це створює візуальний безлад і ускладнює швидке "сканування" коду очима. 
1. public class MyClass { // ПОГАНО: Дужка на тому ж рядку
2.     public void MyMethod(bool condition) { // ПОГАНО: Дужка на тому ж рядку
3.         if (condition) { // ПОГАНО: Дужка на тому ж рядку
4.             // ...
5.         }
6.     }
7. }

     Гарний код (рядок 1-11) дотримується стандарту Allman. Зверніть увагу, як легко прослідкувати структуру: дужки класу MyClass чітко огортають метод, а дужки методу MyMethod — блок if. Кожен блок візуально відділений, що значно знижує когнітивне навантаження.
1. public class MyClass
2. {
3.     public void MyMethod(bool condition)
4.     {
5.         if (condition)
6.         {
7.             // Тіло умови чітко видно
8.             // ...
9.         }
10.     }
11. }
    
   Якщо форматування визначає візуальну структуру коду, то іменування – це його семантичне ядро. Чіткі конвенції іменування є ключовими, оскільки вони дозволяють розробнику миттєво зрозуміти призначення та область видимості елемента коду (це приватне поле, публічний метод або локальна змінна), ще до аналізу його реалізації.
   У C# та екосистемі .NET діють суворі, чітко визначені правила, встановлені Microsoft. Вони створюють єдиний "словник" та граматику для всієї платформи, що робить код передбачуваним.
   PascalCase (або UpperCamelCase): Використовується для всіх публічних (public) або внутрішніх (internal) членів, що складають "зовнішній API" класу. 
Назви класів, інтерфейсів, перелічень (enum) та структур (struct).
Назви публічних методів. Назви публічних властивостей (Properties) та подій (Events). Використання PascalCase – це сигнал для іншого розробника: "Цей елемент призначений для взаємодії, на нього можна покладатися".
     camelCase (або lowerCamelCase): Використовується для внутрішніх деталей реалізації. Це: Локальні змінні (оголошені всередині методу). Параметри (аргументи) методів.
     Приватні поля (Private Fields): Для приватних полів, що зберігають стан класу, стандартом є префікс _ та camelCase (наприклад, _userService). Цей префікс _ миттєво візуально відділяє поля, що належать екземпляру класу (і доступні у всіх його методах), від локальних змінних, що "живуть" лише всередині одного методу.
     Поганий приклад коду (рядок 1-18) демонструє хаотичну суміш стилів (snake_case з Python/Ruby, неправильний регістр), що змушує читача "спотикатися" на кожному рядку і розшифровувати, що є що.
     
1. // ПОГАНО: Використання snake_case. Має бути `UserService`.
2. public class user_service 
3. {
4.     // ПОГАНО: Це публічне *поле*. Це грубо порушує інкапсуляцію.
5.     // Хоча ім'я `UserName` і є PascalCase, сам підхід невірний.
6.     public string UserName; 
7. 
8.     // ПОГАНО: Невірний регістр. Має бути `_id` (використання `_camelCase`).
9.     private int _ID; 
10. 
11.     // ПОГАНО: Публічний метод *завжди* має бути PascalCase (`GetData`).
12.     // `getdata` виглядає як локальна змінна.
13.     public void getdata() 
14.     {
15.         // ПОГАНО: `snake_case` для локальної змінної. Має бути `userName`.
16.         var user_name = "test"; 
17.     }
18. }

     Хороший код (рядок 1-17) читається "безшовно". Кожен ідентифікатор чітко повідомляє про свою роль ще до того, як ми прочитаємо його назву, лише за його формою.
1. // ДОБРЕ: Назва класу в PascalCase
2. public class UserService
3. {
4.     // ДОБРЕ: Використання публічної *властивості* (Property)
5.     // з PascalCase. Це забезпечує інкапсуляцію.
6.     public string UserName { get; set; } 
7. 
8.     // ДОБРЕ: Приватне поле з префіксом `_` та camelCase
9.     private int _id; 
10. 
11.     // ДОБРЕ: Публічний метод у PascalCase
12.     public void GetData()
13.     {
14.         // ДОБРЕ: Локальна змінна у camelCase
15.         var userName = "test"; 
16.     }
17. }
     
     «Магічні» значення – це константи (числа, рядки), що використовуються безпосередньо в коді без пояснення їхнього сенсу. Їх слід замінювати іменованими константами або змінними.
Поганий приклад магічних значень (рядок 1-7)
1. // Що означає 5? Що таке "admin"?
2. if (user.Role == 5 && user.Type == "admin")
3. {
4.     // ...
5. }
6. 
7. // Що таке 0.2?
8. var tax = order.Total * 0.2;
Гарний приклад іменування констант (рядок 1-11)
1. // Значення винесені в константи з чіткими іменами
2. private const int AdministratorRole = 5;
3. private const string AdminUserType = "admin";
4. private const decimal VatRate = 0.2m;
5. 
6. if (user.Role == AdministratorRole && user.Type == AdminUserType)
7. {
8.     // ...
9. }
10. 
11. var tax = order.Total * VatRate;
      
      Хороші коментарі пояснюють чому, але для публічного API (Application Programming Interface) коду необхідно також пояснювати що він робить. Для цього існують спеціалізовані формати коментарів, які інтегруються з IDE та можуть використовуватися для автоматичної генерації документації.
      Системи документації: У світі C#/.NET стандартом є XML Documentation Comments. Цей стандарт слугує одній меті: надати структурований опис коду.
      XML-документація в C#: Це коментарі, що починаються з трьох слешів (///). Visual Studio автоматично генерує шаблон при їх введенні над методом, класом чи властивістю.
Основні теги:
* <summary>: Загальний опис того, що робить елемент.
* <param name="name">: Опис конкретного параметра методу.
* <returns>: Опис того, що повертає метод.
* <exception cref="ExceptionType">: Опис винятку, який може згенерувати метод.
* <example>: (Необов'язково, але корисно) Приклад використання.
    Код без документації (рядок 1-15): Такий метод абсолютно незрозумілий для іншого розробника без аналізу його внутрішньої реалізації. Що він повертає? Які параметри очікує? Які можуть бути помилки?
1. // ПОГАНО
2. public string ProcessUserData(int id, bool flag)
3. {
4.     if (id <= 0)
5.     {
6.         throw new ArgumentException("id");
7.     }
8.     
9.     var user = _db.GetUser(id);
10.     if (flag)
11.     {
12.         return user.FullName.ToUpper();
13.     }
14.     return user.FullName.ToLower();
15. }

     З повною XML-документацією (рядок 1-22): тепер, при наведенні миші на ProcessUserData в IDE, розробник миттєво отримає всю необхідну інформацію.

1. // ДОБРЕ
2. /// <summary>
3. /// Обробляє дані користувача, повертаючи його повне ім'я
4. /// у вказаному регістрі.
5. /// </summary>
6. /// <param name="id">Унікальний ідентифікатор користувача.</param>
7. /// <param name="flag">
8. /// Якщо true, ім'я повертається у верхньому регістрі.
9. /// Якщо false, ім'я повертається у нижньому регістрі.
10. /// </param>
11. /// <returns>Відформатоване повне ім'я користувача.</returns>
12. /// <exception cref="ArgumentException">
13. /// Виникає, якщо <paramref name="id"/> менше або дорівнює нулю.
14. /// </exception>
15. public string ProcessUserData(int id, bool flag)
16. {
17.     if (id <= 0)
18.     {
19.         // ... (реалізація)
20.     }
21.     // ... (реалізація)
22. }

     Хоча загальні принципи чистого коду є універсальними, їхня конкретна реалізація та інструментарій в екосистемі C# та .NET чітко визначені Microsoft C# Code Conventions. Microsoft надає набір вбудованих інструментів для забезпечення єдиного стилю кодування. Інструменти для забезпечення стилю в .NET: .editorconfig - це текстовий файл, який розміщується в корені проєкту або рішення. Він дозволяє декларативно описати всі правила стилю: відступи, стиль дужок, правила іменування та багато іншого. Visual Studio, VS Code та інші сучасні IDE автоматично зчитують цей файл і застосовують його правила під час написання коду. Це стандарт де-факто для конфігурації стилю в .NET.
Roslyn Analyzers - це "лінтери", вбудовані безпосередньо в компілятор C# (Roslyn). Вони аналізують код в реальному часі. Вони не лише перевіряють стиль (заданий в .editorconfig), але й шукають потенційні помилки, проблеми з продуктивністю, "запахи коду" та порушення найкращих практик. Багато правил (наприклад, з StyleCop.Analyzers) можна додати через NuGet-пакети.
     Test-Driven Development (TDD) — це не просто техніка тестування, а фундаментальна методологія проєктування коду. Вона безпосередньо впливає на його структуру та якість, змушуючи розробника писати код, який за визначенням є ізольованим, сфокусованим та придатним до підтримки.
Основи TDD та цикл "Red-Green-Refactor": Процес TDD є ітеративним і складається з трьох кроків:
* Red (Червоний): Спочатку пишеться юніт-тест, який описує бажану функціональність. Цей тест очікувано не проходить (стає "червоним"), оскільки реалізація ще не існує.
* Green (Зелений): Пишеться мінімально необхідний обсяг коду для того, щоб цей тест пройшов (став "зеленим").
* Refactor (Рефакторинг): Коли тест "зелений", код реалізації покращується: прибирається дублювання, покращуються імена, застосовуються правила стилю. Головне — тест має залишатися "зеленим".
Організація коду з урахуванням тестів в .NET MAUI: TDD є однією з головних причин, чому архітектура MVVM є настільки важливою. Логіка, винесена у ViewModel (яка є звичайним C# класом), може бути легко протестована юніт-тестами без запуску UI.
Підходи до написання тестів (Шаблон "AAA"): Для підтримки тестів, вони самі мають бути чистими. Використовуйте шаблон Arrange, Act, Assert:
* Arrange: Налаштування початкового стану (створення ViewModel, мокування сервісів).
* Act: Виконання дії, що тестується (виклик команди, зміна властивості).
* Assert: Перевірка очікуваного результату
Приклад поганого коду (рядок 1-11), де великий, незрозумілий тест:
1. // ПОГАНО
2. [Fact]
3. public void TestViewModel()
4. {
5.     var vm = new MainViewModel(); // Arrange
6.     Assert.Equal("Натисніть кнопку", vm.StatusText); // Assert 1
7.     vm.IncrementCommand.Execute(null); // Act 1
8.     Assert.Equal("Натиснуто 1 разів", vm.StatusText); // Assert 2
9.     for(int i=0; i<10; i++) { vm.IncrementCommand.Execute(null); } // Act 2
10.     Assert.False(vm.IncrementCommand.CanExecute(null)); // Assert 3
11. }

     Приклад хорошого коду (рядок 1-32) , де сфокусовані тести з чітким ім'ям та структурою AAA:
1. // ДОБРЕ
2. [Fact]
3. public void IncrementCommand_Should_UpdateStatusText_OnFirstClick()
4. {
5.     // Arrange
6.     var viewModel = new MainViewModel();
7.     var expectedText = "Натиснуто 1 разів";
8. 
9.     // Act
10.     viewModel.IncrementCommand.Execute(null);
11. 
12.     // Assert
13.     Assert.Equal(expectedText, viewModel.StatusText);
14. }
15. 
16. [Fact]
17. public void IncrementCommand_Should_DisableCommand_When_LimitIsReached()
18. {
19.     // Arrange
20.     var viewModel = new MainViewModel();
21.     // (Припускаємо, що ліміт 10)
22.     for (int i = 0; i < 9; i++)
23.     {
24.         viewModel.IncrementCommand.Execute(null);
25.     }
26.     
27.     // Act (10-й клік)
28.     viewModel.IncrementCommand.Execute(null);
29. 
30.     // Assert
31.     Assert.False(viewModel.IncrementCommand.CanExecute(null));
32. }

     Для гарантованого дотримання стандартів якості коду використовуються автоматизовані платформи, що доповнюють локальні інструменти IDE та .editorconfig.
     SonarQube (та його хмарний аналог SonarCloud) є індустріальним стандартом для безперервного статичного аналізу коду (SAST). Платформа сканує кодову базу та надає централізований, деталізований звіт, ідентифікуючи:
      * Вразливості безпеки: Ризики SQL-ін'єкцій, жорстко закодовані облікові дані, використання слабких криптографічних алгоритмів.
      * Потенційні баги: Логічні помилки, ризики NullReferenceException, неправильна обробка ресурсів.
      * Code Smells: Порушення принципів дизайну, дублювання коду, надмірна складність (цикломатична складність).
SonarQube кількісно оцінює технічний борг та дозволяє відстежувати динаміку якості коду.
Процес контролю якості автоматизується на двох рівнях:
      * Локальний рівень (Git Hooks): Використання скриптів (наприклад, pre-commit hook) дозволяє автоматично запускати форматування (dotnet format) та базові лінтери перед кожним комітом. Це гарантує, що неформатований код не потрапляє до репозиторію.
      * Серверний рівень (SonarQube Quality Gate): SonarQube інтегрується в CI-пайплайн (Azure DevOps, GitHub Actions). Після збірки та виконання тестів, сканер SonarQube аналізує код. Якщо виявлені проблеми порушують Quality Gate — набір визначених правил (напр., "немає нових критичних багів", "покриття тестами > 80%") — SonarQube автоматично блокує злиття Pull Request. Це переводить оцінку якості з суб'єктивної в об'єктивну площину.
     Поганий код (рядок 1-21): Цей код поєднує всі погані практики: логіка в UI, "магічні" числа, погані імена, відсутність форматування та коментарів.
1. // ПОГАНО (MainPage.xaml.cs)
2. public partial class MainPage : ContentPage
3. {
4.     private int c = 0; // ПОГАНО: "c" - що це?
5.     public MainPage() { InitializeComponent(); }
6. 
7.     // ПОГАНО: Вся логіка в обробнику подій
8.     private void Button_Clicked(object sender, EventArgs e)
9.     {
10.         c++;
11.         if (c > 10) // ПОГАНО: Магічне число 10
12.         {
13.             (sender as Button).IsEnabled = false;
14.             // ПОГАНО: Пряма маніпуляція UI
15.             myLabel.Text = "Досить!";
16.             myLabel.TextColor = Colors.Red;
17.         } else {
18.             myLabel.Text = "Натиснуто " + c + " разів"; // Конкатенація
19.         }
20.     }
21. }

     Гарний код (рядок 1-28): Логіка повністю винесена, імена описові, константи визначені, код готовий до тестування.
1. // ДОБРЕ (MainViewModel.cs)
2. public partial class MainViewModel : ObservableObject
3. {
4.     private const int ClickLimit = 10;
5.     private int _clickCount = 0;
6. 
7.     [ObservableProperty]
8.     private string _statusText = "Натисніть кнопку";
9. 
10.     [ObservableProperty]
11.     private Color _statusColor = Colors.Black;
12.     
13.     [RelayCommand(CanExecute = nameof(CanIncrement))]
14.     private void Increment()
15.     {
16.         _clickCount++;
17.         StatusText = $"Натиснуто {_clickCount} разів";
18. 
19.         if (_clickCount >= ClickLimit)
20.         {
21.             StatusText = "Досить!";
22.             StatusColor = Colors.Red;
23.             IncrementCommand.NotifyCanExecuteChanged();
24.         }
25.     }
26. 
27.     private bool CanIncrement() => _clickCount < ClickLimit;
28. }



     ВИСНОВКИ
     Правила оформлення коду — це не питання особистих уподобань, а фундаментальна інженерна дисципліна та ключовий елемент професійної комунікації. 
     У контексті розробки на .NET MAUI, де тісно переплітаються декларативна розмітка XAML та імперативна логіка C#, ця дисципліна стає критично важливою для уникнення хаосу й забезпечення довгострокової підтримки проєкту. Успіх починається не з відступів, а з чистої архітектури: суворе дотримання патерну MVVM є першоосновою, що забезпечує ізоляцію логіки, можливість її тестування за методологією TDD та чіткий поділ відповідальності. Єдині конвенції іменування C# та стандарти форматування XAML слугують спільною мовою команди. Проте покладатися виключно на людську дисципліну — неефективно. Саме тому ключем до успіху є автоматизація: процес контролю якості має починатися локально — з упровадження файлу .editorconfig для уніфікації стилю в IDE — і завершуватися на серверному рівні, де інструменти статичного аналізу, такі як SonarQube, інтегруються в CI/CD-пайплайни. Такий підхід об’єктивно гарантує якість, переводить суб’єктивні суперечки про стиль у площину “проходження воріт якості” та є прямою інвестицією у продуктивність команди й життєвий цикл програмного продукту.





     ДОДАТОК А
     
Відеозапис презентації результатів практичного заняття: https://youtu.be/8Sx54PdXSW4


Таймкоди:
00:00 - Привітання і представлення теми проекту
00:11 - Важливість написання чистого коду
00:45 - Опис архітектури .Net MAUI
01:26 - Опис візуального форматування
02:27 - Приклади кодів поганого і гарного форматування
03:00 - Конвенції іменування
04:12 - Приклади кодів поганого і гарного іменування
04:32 - Константи і магічні значення
05:07 - Документування коду
05:52 - Поганий приклад документування коду
06:08 - Гарний приклад документування коду
06:17 - Інструменти для дотримання стандартів якості коду
07:14 - TDD методологія проектування коду
08:33 - Автоматизація контролю якості
10:01 - Загальний поганий приклад для .Net MAUI
10:29 - Гарний приклад для .Net MAUI
10:38 – Висновки


ДОДАТОК Б
Графічні матеріали

Рисунок Б.1 — Титульний слайд


Рисунок Б.2 — Слайд про стандарти написання чистого коду


Рисунок Б.3 — Слайд про Архітектуру .NET MAUI: MVVM


Рисунок Б.4 — Слайд про Архітектуру .NET MAUI: MVVM


Рисунок Б.5— Слайд про Форматування: Відступи та Дужки


Рисунок Б.6— Слайд про Конвенції іменування



Рисунок Б.7— Слайд про Конвенції іменування



Рисунок Б.8— Слайд про Конвенції іменування


Рисунок Б.9— Слайд про Документування коду


Рисунок Б.10— Слайд про Документування коду


Рисунок Б.11— Слайд про Документування коду


Рисунок Б.12— Слайд про Конвенції стилю та Інструменти

Рисунок Б.13— Слайд про Автоматизація Контролю Якості



Рисунок Б.14— Слайд про Автоматизація Контролю Якості


Рисунок Б.15— Слайд про Приклад поганого коду


Рисунок Б.16— Слайд про Приклад хорошого коду


Рисунок Б.17— Слайд про Висновки


Рисунок Б.18— Слайд про Джерела
