МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 5 з дисципліни
Аналіз та рефакторинг коду





Виконав:                                                                Перевірив:
ст. гр. ПЗПІ-23-5                				ст. викладач кафедри ПІ
Гущин Михайло Валерійович			Сокорчук Ігор Петрович

























Харків 2025


1 ІСТОРІЯ ЗМІН
      №      ДатаВерсія звітуОпис змін та виправлень      1      25.12.2025      0.1      Початкова версія

      




2 ЗАВДАННЯ

1. Розгорнути створену програмну систему:
     Використовуючи інструменти для розгортання (наприклад, Docker, 
Kubernetes, хмарні сервіси), розгорнути серверну частину, веб-клієнт, 
мобільний клієнт та IoT клієнт.
     Налаштувати середовище для роботи програмної системи (сервер, 
база даних, мережеві налаштування).
2. Перевірити та налаштувати роботу розгорнутої програмної системи:
     Провести перевірку стабільності та коректності роботи усіх 
компонентів програмної системи (серверна частина, IoT клієнт, база даних, 
API).
     Виконати налаштування параметрів серверної частини, клієнтських 
застосунків та мережевих протоколів для коректної роботи системи.
3. Продемонструвати описану у розділі 2.2 Vision & Scope 
функціональність програмної системи:
     Описати та продемонструвати всі функції, передбачені в розділі 
2.2 Vision & Scope, включаючи бізнес логіку, функції адміністрування та 
взаємодію між серверною частиною та клієнтами.
     Перевірити реалізацію всіх необхідних функціональних 
можливостей програмної системи.

3 ОПИС ВИКОНАНОЇ РОБОТИ

	
     Архітектура розгортання системи моніторингу складається з двох логічних частин: серверної (Server) та IoT-компонентів, що взаємодіють між собою через спільну Docker-мережу iot-shared-network.
     Серверна частина включає кілька ключових сервісів (див. дод. Б). Контейнер PostgreSQL на базі офіційного образу postgres:15-alpine використовується для надійного зберігання даних про користувачів, ідентифікатори станцій та історичну телеметрію. Доступ до бази даних здійснюється через стандартний порт 5432, а дані зберігаються у виділеному volume postgres_data, що забезпечує їх збереження між перезапусками контейнера. Для забезпечення безперервної роботи контейнер має увімкнену політику автоматичного перезапуску.
     Сервіс міграцій Backend Migrate є тимчасовим компонентом, який використовується для автоматичного створення актуальної структури таблиць у базі даних. Він базується на тому самому образі бекенд-застосунку і запускається лише після того, як PostgreSQL стане готовим до обробки запитів. Виконання міграцій здійснюється за допомогою команди npm run migrate, а політика перезапуску для цього контейнера вимкнена, оскільки міграції виконуються одноразово під час старту системи.
     Основний API-контейнер Backend API забезпечує роботу REST API на Node.js та TypeScript, публікується на порту 3000 і виконує обробку HTTP-запитів від клієнтських застосунків і IoT-пристроїв. Сервіс підтримує JWT-автентифікацію та обробляє запити на управління станціями, сенсорними даними та телеметрією. Для гарантування коректного запуску контейнер залежить як від доступності бази даних, так і від успішного завершення міграцій, а у випадку збою передбачений автоматичний перезапуск.
     IoT-компоненти системи складаються з декількох взаємопов’язаних сервісів (див. дод. Б). Python-емулятор (Python Emulator) відтворює роботу реального IoT-пристрою, генерує дані сенсорів і надсилає їх до MQTT-брокера. Контейнер налаштований через змінні середовища, які включають адресу і порт MQTT-брокера, URL бекенд-API, облікові дані користувача та унікальний ідентифікатор станції. Емулятор підключається до брокера лише після того, як останній буде готовий до обробки повідомлень, і працює в межах спільної мережі для забезпечення взаємодії з іншими компонентами.
     MQTT-брокер Mosquitto забезпечує обмін повідомленнями між IoT-пристроями та сервером через протокол MQTT. Він використовує офіційний образ eclipse-mosquitto і конфігураційний файл mosquitto.conf, що дозволяє адаптувати стандартні параметри під потреби системи. Брокер відкритий для підключення через порт 1883 і інтегрований у спільну мережу контейнерів.
TypeScript-брідж (MQTT Bridge) виконує функцію посередника між MQTT-брокером та серверним API, підписуючись на необхідні топіки та передаючи отримані дані на REST API бекенду. Контейнер налаштований через змінні середовища, які включають адресу брокера, URL API та облікові дані для авторизації. Для коректного запуску він залежить від старту брокера і емулятора, що забезпечує послідовність запуску компонентів.
     Усі контейнери взаємодіють через спільну зовнішню Docker-мережу iot-shared-network, що забезпечує коректну маршрутизацію запитів і повідомлень між сервісами. Така архітектура дозволяє гнучко масштабувати окремі компоненти, ізолювати їх у контейнери та забезпечувати надійність і повторюваність середовища для розгортання системи.


4 ВИСНОВКИ
     
     У ході виконання лабораторної роботи було успішно реалізовано розгортання комплексної системи моніторингу IoT-пристроїв з використанням технології контейнеризації Docker. Архітектура системи побудована за принципом модульності та розділення відповідальності на серверну частину та IoT-компоненти, що забезпечує легкість управління, масштабування та підтримку системи.
     Серверна частина включає базу даних PostgreSQL для надійного зберігання даних, сервіс міграцій для автоматичного створення актуальної структури таблиць і основний API-контейнер для обробки запитів користувачів та IoT-пристроїв. IoT-компоненти складаються з емулятора пристрою, MQTT-брокера Mosquitto та TypeScript-бріджа, які забезпечують генерацію, передачу та інтеграцію телеметричних даних у базу даних через REST API.
     Використання Docker Compose та Bash-скриптів дозволило автоматизувати запуск усіх сервісів у правильному порядку, забезпечити залежності між компонентами та гарантувати доступність бекенду перед стартом IoT-пристроїв. Застосування спільної Docker-мережі забезпечило коректну взаємодію між контейнерами та надійну маршрутизацію повідомлень.
     Реалізація даної системи демонструє ефективність підходу контейнеризації для побудови модульних, масштабованих і повторюваних середовищ розгортання IoT-рішень. Досягнутої конфігурації достатньо для відтворюваного тестування, розвитку та інтеграції додаткових функціональних модулів, що робить систему гнучкою та зручною для експлуатації в лабораторних та експериментальних умовах.





ДОДАТОК А

Відеозапис

Відеозапис презентації результатів лабораторної роботи: 
https://youtu.be/Q-s5-od_tlM

Хронологічний опис відеозапису:

00:00 - представлення та завдання на лабораторну работу.
00:18 - Dokerfile для бекенду
00:56 - Dokerfile для bridge
00:56 - Dokerfile для bridge
01:21 - Dokerfile для емулятора
01:50 - docker-compose для розгортання серверної частини
03:31 - скрипт для запуску бекенду
04:51 - запуск бекенду та перевірка роботи
05:27 - підтягування бекапу бази даних
05:43 - docker-compose для розгортання IoTчастини
07:18 - скрипт для запуску IoT частини
08:52 - запуск IoT частини та перевірка роботи




ДОДАТОК Б

Backend.sh
1. #!/bin/bash
2. set -e
3. 
4. 
5. DEFAULT_DB_USER="postgres"
6. DEFAULT_DB_PASS="postgres"
7. DEFAULT_DB_NAME="iot_db"
8. DEFAULT_DB_HOST="postgres"
9. DEFAULT_DB_PORT="5432"
10. 
11. NETWORK_NAME="iot-shared-network"
12. COMPOSE_FILE="docker-compose.backend.yml"
13. 
14. command -v docker >/dev/null || { echo " Docker не встановлено"; exit 1; }
15. command -v docker-compose >/dev/null || { echo " Docker Compose не встановлено"; exit 1; }
16. 
17. echo " Налаштування PostgreSQL (Enter = default)"
18. 
19. read -p "DB USER [$DEFAULT_DB_USER]: " DB_USER
20. DB_USER=${DB_USER:-$DEFAULT_DB_USER}
21. 
22. read -p "DB PASSWORD [$DEFAULT_DB_PASS]: " DB_PASS
23. DB_PASS=${DB_PASS:-$DEFAULT_DB_PASS}
24. 
25. read -p "DB NAME [$DEFAULT_DB_NAME]: " DB_NAME
26. DB_NAME=${DB_NAME:-$DEFAULT_DB_NAME}
27. 
28. DATABASE_URL="postgres://${DB_USER}:${DB_PASS}@${DEFAULT_DB_HOST}:${DEFAULT_DB_PORT}/${DB_NAME}"
29. 
30. export DATABASE_URL
31. export DB_USER
32. export DB_PASS
33. export DB_NAME
34. 
35. echo " DATABASE_URL = $DATABASE_URL"
36. 
37. 
38. if ! docker network ls --format '{{.Name}}' | grep -q "^${NETWORK_NAME}$"; then
39.     echo " Створюємо мережу $NETWORK_NAME..."
40.     docker network create $NETWORK_NAME
41. else
42.     echo " Мережа $NETWORK_NAME вже існує"
43. fi
44. 
45. 
46. echo " Піднімаємо Backend + PostgreSQL..."
47. docker-compose -f $COMPOSE_FILE up -d
48. 
49. echo " Backend запущено"
50. docker ps --filter "network=$NETWORK_NAME"
51.

Deploy.sh
1. #!/bin/bash
2. set -e
3. 
4. NETWORK_NAME="iot-shared-network"
5. COMPOSE_FILE="docker-compose.iot.yml"
6. BACKEND_HEALTH="http://localhost:3000/healthz"
7. 
8. 
9. command -v docker >/dev/null || { echo "Docker не встановлено"; exit 1; }
10. command -v docker-compose >/dev/null || { echo "Docker Compose не встановлено"; exit 1; }
11. 
12. echo " IoT параметри (Enter = default)"
13. 
14. read -p " Email [user@example.com]: " IOT_USER
15. IOT_USER=${IOT_USER:-user@example.com}
16. 
17. read -s -p " Password [string]: " IOT_PASS
18. echo
19. IOT_PASS=${IOT_PASS:-string}
20. 
21. read -p " Station ID [98f6a2b1-5c3d-4e8f-9a1b-7c6d5e4f3a2b]: " STATION_ID
22. STATION_ID=${STATION_ID:-98f6a2b1-5c3d-4e8f-9a1b-7c6d5e4f3a2b}
23. 
24. export IOT_USER
25. export IOT_PASS
26. export STATION_ID
27. 
28. 
29. if ! docker network ls --format '{{.Name}}' | grep -q "^${NETWORK_NAME}$"; then
30.     echo " Створюємо мережу $NETWORK_NAME..."
31.     docker network create $NETWORK_NAME
32. else
33.     echo " Мережа $NETWORK_NAME вже існує"
34. fi
35. 
36. echo " Очікуємо Backend..."
37. until curl -s $BACKEND_HEALTH >/dev/null 2>&1; do
38.     printf "."
39.     sleep 2
40. done
41. echo -e "\n Backend доступний"
42. 
43. 
44. echo " Запускаємо IoT + MQTT + Bridge..."
45. docker-compose -f $COMPOSE_FILE up -d
46. 
47. echo " Контейнери в мережі $NETWORK_NAME:"
48. docker ps --filter "network=$NETWORK_NAME"
49.





Docker-compose-backend
1. version: "3.8"
2. 
3. services:
4.   postgres:
5.     image: postgres:15-alpine
6.     container_name: iot_postgres
7.     restart: always
8.     environment:
9.       POSTGRES_USER: ${DB_USER}
10.       POSTGRES_PASSWORD: ${DB_PASS}
11.       POSTGRES_DB: ${DB_NAME}
12.     ports:
13.       - "5432:5432"
14.     volumes:
15.       - postgres_data:/var/lib/postgresql/data
16.     networks:
17.       - iot-network
18. 
19.   backend-migrate:
20.     image: qwertymvh/iot_backend:latest
21.     container_name: iot_backend_migrate
22.     depends_on:
23.       - postgres
24.     environment:
25.       DATABASE_URL: ${DATABASE_URL}
26.       JWT_SECRET: supersecretkey
27.     command: sh -c "npm run migrate"
28.     restart: "no"
29.     networks:
30.       - iot-network
31. 
32.   backend-api:
33.     image: qwertymvh/iot_backend:latest
34.     container_name: iot_backend
35.     restart: always
36.     depends_on:
37.       - postgres
38.       - backend-migrate
39.     environment:
40.       DATABASE_URL: ${DATABASE_URL}
41.       PORT: 3000
42.       JWT_SECRET: supersecretkey
43.     ports:
44.       - "3000:3000"
45.     networks:
46.       - iot-network
47. 
48. networks:
49.   iot-network:
50.     name: iot-shared-network
51.     external: true
52. 
53. volumes:
54.   postgres_data:
55.

Docker-compose-iot

1. 
2. services:
3. 
4.   python-emulator:
5.     image: qwertymvh/python_iot:latest
6.     container_name: python_iot
7.     environment:
8.       MQTT_BROKER: mosquitto
9.       MQTT_PORT: 1883
10.       DATABASE_URL: postgres://postgres:postgres@postgres:5432/iot_db
11.       API_URL: http://iot_backend:3000/api/v1
12.       IOT_USER: ${IOT_USER}
13.       IOT_PASS: ${IOT_PASS}
14.       STATION_ID: ${STATION_ID}
15.     depends_on:
16.       - mosquitto
17.     networks:
18.       - iot-network
19. 
20. 
21.   mosquitto:
22.     image: eclipse-mosquitto:2.0
23.     container_name: mqtt_broker
24.     ports:
25.       - "1883:1883"
26.     volumes:
27.       - ./mosquitto.conf:/mosquitto/config/mosquitto.conf
28.     networks:
29.       - iot-network
30. 
31.   
32.   mqtt-bridge:
33.     image: qwertymvh/ts_mqtt_bridge:latest
34.     container_name: ts_mqtt_bridge
35.     environment:
36.       MQTT_BROKER: mqtt://mosquitto:1883
37.       API_URL: http://iot_backend:3000/api/v1
38.       BRIDGE_EMAIL: ${IOT_USER}
39.       BRIDGE_PASSWORD: ${IOT_PASS}
40.     depends_on:
41.       - mosquitto
42.       - python-emulator
43.     networks:
44.       - iot-network
45. 
46. networks:
47.   iot-network:
48.     name: iot-shared-network
49.     external: true
50.
2


