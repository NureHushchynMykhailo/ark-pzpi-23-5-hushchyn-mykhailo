МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з практичного заняття №2 з дисципліни
аналіз та рефакторінг коду




Виконав:                                                                     Перевірив:
ст. гр. ПЗПІ-23-5                        			   ст. викладач кафедри ПІ
Гущин М.В.           		   Сокорчук Ігор Петрович


Харків 2025

ІСТОРІЯ ЗМІН
        №        ДатаВерсія звіту        Опис змін та виправлень        1        06.12.2025        0.1        Початкова версія


1 МЕТА РОБОТИ
     Дослідити та проаналізувати типові проблеми в коді, що виникають під час розробки мобільних додатків на платформі C# .NET MAUI, та продемонструвати практичне застосування трьох методів рефакторингу: Push Down Field, Replace Delegation with Inheritance та Replace Array with Object, з метою підвищення читабельності, підтримуваності та якості програмного коду.     
     2 ОПИС ВИКОНАНОЇ РОБОТИ
     Під час розробки мобільних додатків на платформі C# .NET MAUI код проєкту з часом ускладнюється внаслідок постійного розширення функціональності, повторного використання компонентів та внесення змін у бізнес-логіку. Це часто призводить до появи надлишкових полів у базових класах, зайвої делегації між класами та використання масивів для зберігання логічно різнорідних даних, що негативно впливає на читабельність, підтримуваність і масштабованість програмного коду. Для усунення зазначених проблем у даній роботі розглядаються такі методи рефакторингу, як «Переміщення поля в підклас (Push Down Field)», «Заміна делегації наслідуванням (Replace Delegation with Inheritance)» та «Заміна масиву об’єктом (Replace Array with Object)», які дозволяють покращити структуру коду, зробити архітектуру застосунку більш зрозумілою та полегшити його подальший супровід.
     У процесі розробки на C# часто виникає ситуація, коли в базових класах оголошуються поля, які фактично використовуються лише в окремих підкласах. Це призводить до перевантаження базових класів, ускладнення їх структури та зниження читабельності коду. Поле стає зайвим для більшості підкласів, що ускладнює підтримку та розширення функціональності застосунку і порушує принцип єдиної відповідальності.
     В прикладі до рефакторингу (рядок 1-21 ) базовий клас містить поле AdminCode, яке використовується тільки в AdminPageViewModel. Для MainPageViewModel воно зайве, що робить код менш зрозумілим і порушує принцип єдиної відповідальності.

1. public class BaseViewModel
2. {
3.     protected string AdminCode;
4. }
5. 
6. public class MainPageViewModel : BaseViewModel
7. {
8.     public void LoadData()
9.     {
10.         // Логіка завантаження даних
11.         // AdminCode тут не використовується
12.     }
13. }
14. 
15. public class AdminPageViewModel : BaseViewModel
16. {
17.     public bool ValidateAdmin()
18.     {
19.         return AdminCode == "1234";
20.     }
21. }

     В прикладі після рефакторингу (рядок 1-22) поле AdminCode перенесено з базового класу у підклас, де воно реально використовується. Це спрощує базовий клас, робить ієрархію логічнішою та покращує читабельність коду.
     
1. public class BaseViewModel
2. {
3.     // Базовий клас більше не містить непотрібних полів
4. }
5. 
6. public class MainPageViewModel : BaseViewModel
7. {
8.     public void LoadData()
9.     {
10.         // Логіка завантаження даних
11.     }
12. }
13. 
14. public class AdminPageViewModel : BaseViewModel
15. {
16.     private string AdminCode;
17. 
18.     public bool ValidateAdmin()
19.     {
20.         return AdminCode == "1234";
21.     }
22. }
23.
     Перенесення поля у підклас дозволяє зробити базовий клас легшим і більш зрозумілим, уникнути надлишкових залежностей та покращити підтримуваність коду. Ієрархія класів стає логічнішою, кожен підклас містить лише ті поля, які йому необхідні, що спрощує подальше розширення функціональності та забезпечує дотримання принципу єдиної відповідальності (SRP).
     Інша проблема виникає коли клас фактично дублює функціональність іншого класу через делегацію, просто передаючи виклики методів. Це створює зайвий код, ускладнює структуру проекту та знижує читабельність. 
     Наприклад, клас AppLogger (рядок 1-18) лише передає виклики методів до LoggerService, що призводить до надмірної кількості класів без реальної функції, ускладнює архітектуру, збільшує шаблонний код та підвищує ризик помилок при внесенні змін. Така структура робить код менш зрозумілим та важким для підтримки. Метод рефакторингу «Заміна делегації наслідуванням (Replace Delegation with Inheritance)» дозволяє усунути зайву делегацію, зробити архітектуру класів більш логічною, спростити код і полегшити його подальший супровід.
     
1. public class LoggerService
2. {
3.     public void Log(string message)
4.     {
5.         // Логування повідомлення
6.         Console.WriteLine(message);
7.     }
8. }
9. 
10. public class AppLogger
11. {
12.     private LoggerService _logger = new LoggerService();
13. 
14.     public void Log(string message)
15.     {
16.         _logger.Log(message);
17.     }
18. }




     Клас AppLogger (рядок 1-13) успадковує метод Log від LoggerService, що прибирає зайву делегацію, спрощує архітектуру і зменшує кількість шаблонного коду.
     
1. public class LoggerService
2. {
3.     public void Log(string message)
4.     {
5.         Console.WriteLine(message);
6.     }
7. }
8. 
9. public class AppLogger : LoggerService
10. {
11.     // Тепер AppLogger успадковує функціонал LoggerService
12.     // і не потребує окремого делегата
13. }

     Заміна делегації наслідуванням дозволяє спростити структуру класів, усуваючи зайві обгортки та дублювання коду. Клас AppLogger тепер успадковує методи LoggerService, що прибирає необхідність створювати окремі делегати і зменшує кількість шаблонного коду. 
     Такий підхід робить архітектуру більш логічною та зрозумілою, підвищує читабельність коду і полегшує його підтримку та масштабування. Усунення зайвої делегації зменшує ризик помилок при внесенні змін у логіку логування, забезпечує простіший контроль за потоками даних і дозволяє швидше розширювати функціональність застосунку, зберігаючи при цьому чистоту та компактність коду.
     Іноді для зберігання логічно різнорідних даних використовують масиви. Наприклад, масив може містити ім’я користувача, електронну пошту та роль одночасно. Цей підхід створює кілька проблем: елементи масиву мають неочевидні індекси, важко зрозуміти, що саме зберігається в кожній позиції, а при додаванні нових даних потрібно змінювати весь код, що працює з масивом. Це ускладнює читабельність, підвищує ймовірність помилок та ускладнює підтримку застосунку.
     До рефакторингу (рядок 1-9) для зберігання інформації про користувача використовувався масив, де кожен елемент відповідав певному атрибуту (ім’я, email, роль, статус). Це ускладнює читабельність коду, оскільки значення елементів не мають явно зрозумілих імен, легко допустити помилку при неправильному порядку або індексах, а також складно додавати нові поля без зміни всіх частин коду, що працюють із масивом.
1. // Масив використовується для зберігання інформації про користувача
2. string[] userData = new string[4];
3. userData[0] = "Ivan";               // Ім'я
4. userData[1] = "ivan@mail.com";      // Email
5. userData[2] = "Admin";              // Роль
6. userData[3] = "Active";             // Статус користувача
7. 
8. // Використання даних
9. Console.WriteLine($"Name: {userData[0]}, Email: {userData[1]}, Role: {userData[2]}, Status: {userData[3]}");

     Після рефакторингу (рядок 1-19) масив, який зберігав інформацію про користувача, замінено на об’єкт класу User, де кожен атрибут користувача (ім’я, email, роль, статус, телефон) представлено як іменована властивість. Це робить код більш зрозумілим, логічним і типобезпечним, оскільки значення тепер мають чіткі імена, а не приховані за індексами масиву.

1. public class User
2. {
3.     public string Name { get; set; }
4.     public string Email { get; set; }
5.     public string Role { get; set; }
6.     public string Status { get; set; }
7.     public string Phone { get; set; }  // Легко додати нове поле
8. }
9. 
10. User user = new User
11. {
12.     Name = "Ivan",
13.     Email = "ivan@mail.com",
14.     Role = "Admin",
15.     Status = "Active",
16.     Phone = "+380501234567"
17. };
18. 
19. Console.WriteLine($"Name: {user.Name}, Email: {user.Email}, Role: {user.Role}, Status: {user.Status}, Phone: {user.Phone}");

     Переваги цього рефакторингу полягають у тому, що дані користувача структуровані, легко додавати нові поля без зміни всіх частин коду, підвищується читабельність і підтримуваність, зменшується ймовірність помилок при роботі з даними, а код стає більш готовим до подальшого масштабування та розширення функціональності мобільного застосунку.

ВИСНОВКИ
     Були досліджені та застосовані три методи рефакторингу коду: «Переміщення поля в підклас (Push Down Field)», «Заміна делегації наслідуванням (Replace Delegation with Inheritance)» та «Заміна масиву об’єктом (Replace Array with Object)». Кожен із методів дозволив вирішити конкретні проблеми: надлишкові поля в базових класах, зайву делегацію між класами та неструктуроване зберігання логічно різнорідних даних. 
     Застосування рефакторингу підвищило читабельність, підтримуваність та логічну структуру коду, зробило ієрархію класів більш зрозумілою та полегшило подальше розширення функціональності мобільного застосунку. Ці методи сприяють створенню чистого, компактного і масштабованого коду, що відповідає принципам об’єктно-орієнтованого програмування та кращим практикам розробки.


     ДОДАТОК А
     
Відеозапис презентації результатів практичного заняття: https://youtu.be/gSnHL9NjL0E


Таймкоди:
00:00 - Привітання
00:07 - Розглянуті методи рефакторингу
01:00 - Проблема: надлишкові поля в базових класах
01:25 - Код до рефакторингу методом переміщення поля в підклас
02:00 - Код після рефакторингу методом переміщення поля в підклас 
02:25 - Переваги переміщення поля в підклас
02:44 - Проблема: Зайва делегація
02:56 - Код до рефакторингу методом заміни делегації наслідуванням
03:32 - Код після рефакторингу методом заміни делегації наслідуванням
04:05 - Переваги заміни делегації наслідуванням
04:34 - Проблема: Масиви для різнорідних даних
05:11 - Код до рефакторингу методом заміни масиву об’єктом
05:37 - Код після рефакторингу методом заміни масиву об’єктом
06:00 - Переваги заміни масиву об’єктом
06:21 - Висновок 

ДОДАТОК Б
Графічні матеріали

Рисунок Б.1 — Титульний слайд

Рисунок Б.2 — Вступ


Рисунок Б.3 — Надлишкові поля в базових класах


Рисунок Б.4 — Код до рефакторингу


Рисунок Б.5— Код після рефакторингу


Рисунок Б.6— Переваги переміщення поля в підклас



Рисунок Б.7— Проблема: Зайва делегація



Рисунок Б.8— До рефакторингу


Рисунок Б.9— Після рефакторингу: Заміна делегації наслідуванням


Рисунок Б.10— Переваги заміни делегації наслідуванням


Рисунок Б.11— Проблема: Масиви для різнорідних данихВ


Рисунок Б.12— До рефакторингу

Рисунок Б.13— Після рефакторингу: Заміна масиву об’єктом


Рисунок Б.14— Переваги заміни масиву об’єктом

Рисунок Б.15— Висновки

