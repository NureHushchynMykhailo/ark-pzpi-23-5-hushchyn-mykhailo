МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 4 з дисципліни
Аналіз та рефакторинг коду





Виконав:                                                                Перевірив:
ст. гр. ПЗПІ-23-5                				ст. викладач кафедри ПІ
Гущин Михайло Валерійович			Сокорчук Ігор Петрович

























Харків 2025


1 ІСТОРІЯ ЗМІН
      №      ДатаВерсія звітуОпис змін та виправлень      1      25.12.2025      0.1      Початкова версія

      




2 ЗАВДАННЯ

1. Розробити будову програмного забезпечення ІоТ клієнта.
2. Створити UML діаграму прецедентів для ІоТ клієнта.
3. Розробити бізнес логіку (математину обробку повʼязаних із предметною областю даних) та функції налаштування ІоТ клієнта.
4. Створити діаграму діяльності для ІоТ клієнта.
5. Створити програмну реалізацію бізнес логіки та функцій налаштування ІоТ клієнта.
6. Перевірити роботу ІоТ клієнта.
7. Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.
8. Створити відеозапис демонстрації описаної у розділі 3.1 Vision & Scope. функціональності IoT клієнта та завантажити цей відеозапис у свій канал на YouTube. При завантаженні відеозапису потрібно обовʼязково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
9. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео.
10. Створити звіт до лабораторної роботи.
11. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua.
12. Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт.


3 ОПИС ВИКОНАНОЇ РОБОТИ

	
     ІоТ-система має трирівневу структуру, що забезпечує збір, обробку та передачу телеметричних даних від сенсорів до серверу для подальшого аналізу та управління контролерами. На рівні сенсорів та контролерів знаходяться фізичні або емуляційні пристрої, які зчитують різні фізичні параметри, такі як pH, розчинений кисень, рівень води, тиск, температура, ORP та каламутність. Контролери змінюють ці параметри, через насоси, клапани, диспенсери кислот або хлору, аератори та фільтри. Для сенсорів реалізовані математичні моделі, що враховують природний дрейф, шум і вплив контролерів.
     На рівні ІоТ-клієнта знаходиться програмний компонент (див. дод. В), який управляє сенсорами та контролерами, обробляє дані і передає їх на сервер. ІоТ-клієнт виконує авторизацію на сервері та отримує токен доступу, ініціалізує сенсори на основі останніх даних станції з API, а також синхронізує стан контролерів для моделювання їхнього впливу на показники сенсорів.
     Бізнес-логіка сенсорів полягає у моделюванні фізичних процесів, що відбуваються на станції, та розумній обробці даних (див. дод. Б). Для кожного типу сенсора визначена власна математична модель: pH-метр враховує вплив диспенсерів кислот і лугів, природний дрейф і шум; датчик розчиненого кисню моделює баланс між споживанням кисню та відновленням завдяки аератору; датчик рівня води обчислює зміни через потоки води та роботу насосів; ORP-метр відображає вплив диспенсера хлору і природного розкладання; датчик тиску враховує роботу насоса і фільтра, падіння тиску та засмічення; термометр моделює вплив зовнішньої температури та роботи насосів; датчик каламутності враховує роботу фільтра і накопичення бруду. Для інших сенсорів використовується випадковий шум для моделювання природних коливань.
     Ключовим елементом бізнес-логіки є обробка та валідація показників перед їхньою передачею на сервер. Дані сенсорів аналізуються за допомогою алгоритму виявлення аномалій на основі Z-Score: якщо нове значення виходить за межі ±4 стандартних відхилень від середнього історичних даних, воно вважається аномальним, і для передачі використовується середнє значення. Таким чином на сервер надсилаються тільки перевірені та коректні показники, що гарантує якість телеметрії.
     Для підтримки обробки даних і виявлення аномалій, значення сенсорів локально зберігаються у JSON-файлі, де зберігається історія останніх п’яти вимірювань для кожного сенсора. Це дозволяє аналізувати тренди, обчислювати середнє та стандартне відхилення, проводити фільтрацію аномалій і формувати більш точну та стабільну телеметрію.
     ІоТ-клієнт формує телеметричні повідомлення у форматі JSON із часовими мітками у UTC та публікує їх на MQTT-топік station/{STATION_ID}/telemetry. Пристрій регулярно оновлює стан контролерів, обчислює фізичні зміни для сенсорів відповідно до математичної моделі, перевіряє наявність аномалій, зберігає локально значення та відправляє тільки перевірені дані на сервер. У разі закінчення терміну дії токена або збою авторизації, клієнт автоматично повторно проходить аутентифікацію, що забезпечує безперервну роботу системи.
     На рівні сервера дані приймаються через MQTT та REST API. Сервер забезпечує авторизацію користувачів, зберігання телеметрії, надання останніх даних сенсорів та станів контролерів для ініціалізації ІоТ-клієнта, а також управління контролерами на основі правил або команд від користувачів.
Таким чином, реалізація поєднує чітку структуру ІоТ-системи - сенсори та контролери, ІоТ-клієнт з бізнес-логікою та сервер із API і MQTT - з комплексною математичною обробкою даних, локальним зберіганням, виявленням аномалій і передачею тільки перевірених значень на сервер, що забезпечує реалістичне моделювання фізичних процесів, стабільну передачу телеметрії та гнучке управління контролерами.
4 ВИСНОВКИ
     
     Під час виконання лабораторної роботи  було розроблено програмне забезпечення IoT-клієнта, яке реалізує бізнес-логіку обробки даних та функції налаштування відповідно до сучасних підходів у сфері IoT та SmartDevice систем.
     У ході роботи спроектовано архітектуру IoT-клієнта з чітким розподілом відповідальності між модулями, що забезпечує зрозумілість коду, його масштабованість та легкість супроводу. Бізнес-логіка клієнта здійснює локальну математичну обробку даних сенсорів, обчислюючи середнє значення та стандартне відхилення, що дозволяє виявляти аномальні показники безпосередньо на стороні клієнта та зменшувати навантаження на сервер.
     Для наочного представлення функціональних можливостей та логіки роботи IoT-клієнта створено UML-діаграму прецедентів та UML-діаграму діяльності. Проведене тестування підтвердило коректність роботи бізнес-логіки та механізмів налаштування клієнта.





ДОДАТОК А

Відеозапис 

Відеозапис презентації результатів лабораторної роботи: https://youtu.be/LSylXm9dqg4

Хронологічний опис відеозапису:
00:00 - представлення та завдання на лабораторну работу.
00:14 - Вступ, опис архітектури системи
01:13 - Брідж. Повний опис файлу mqtt-bridge
04:25 - iot емулятор. Повний опис файлу iot-simulation.py
08:19 - запуск емулятору. Перевірка роботи




ДОДАТОК Б

Графічні матеріали


Рисунок 1 — Діаграма прецедентів для ІоТ клієнта







Рисунок 2 — Діаграма діяльності для ІоТ клієнта








ДОДАТОК В

Iot_simulator.py
1. import time
2. import json
3. import random
4. import requests
5. import os
6. import paho.mqtt.client as mqtt
7. from collections import deque
8. 
9. from datetime import datetime, timezone
10. 
11. 
12. API_URL = os.getenv("API_URL", "http://localhost:4001")
13. MQTT_BROKER = os.getenv("MQTT_BROKER", "test.mosquitto.org")
14. MQTT_PORT = int(os.getenv("MQTT_PORT", 1883))
15. 
16. 
17. USER_EMAIL = os.getenv("IOT_USER", "user@example.com")
18. USER_PASS = os.getenv("IOT_PASS", "string")
19. 
20. 
21. STATION_ID = os.getenv("STATION_ID", "98f6a2b1-5c3d-4e8f-9a1b-7c6d5e4f3a2b")
22. HISTORY_FILE = "sensor_history.json"
23. WINDOW_SIZE = 5
24. 
25. class TelemetryStorage:
26.     """Клас для роботи з файловою системою"""
27.     
28.     @staticmethod
29.     def load_all():
30.         if not os.path.exists(HISTORY_FILE):
31.             return {}
32.         try:
33.             with open(HISTORY_FILE, 'r') as f:
34.                 return json.load(f)
35.         except (json.JSONDecodeError, IOError):
36.             return {}
37. 
38.     @staticmethod
39.     def save_reading(sensor_id, value):
40.         data = TelemetryStorage.load_all()
41.         
42.         history = data.get(sensor_id, [])
43. 
44.         history.append(value)
45.    
46.         if len(history) > WINDOW_SIZE:
47.             history = history[-WINDOW_SIZE:]
48.             
49.         data[sensor_id] = history
50.  
51.         with open(HISTORY_FILE, 'w') as f:
52.             json.dump(data, f, indent=2)
53.             
54.         return history
55.     
56. class SensorEmulator:
57.     def __init__(self, sensor_data):
58.         self.id = sensor_data['sensorId'] 
59.         self.type = sensor_data['type']
60.         self.value = float(sensor_data['value'] or 0.0) 
61.         history = TelemetryStorage.load_all().get(self.id, [])
62.         if history:
63.             self.value = history[-1] 
64.         else:
65.             self.value = float(sensor_data['value'] or 0.0) 
66.    
67.         if self.value == 0.0:
68.             defaults = {
69.                 'ph_meter': 7.2, 
70.                 'do_meter': 8.5, 
71.                 'thermometer': 20.0,
72.                 'level_sensor': 60.0, 
73.                 'pressure_sensor': 3.5,
74.                 'orp_meter': 720.0, 
75.                 'turbidity_meter': 0.5
76.             }
77.             self.value = defaults.get(self.type, 0.0)
78. 
79.     def update_physics(self, actuators):
80.         """
81.         Математична модель: Розрахунок впливу контролерів на показники
82.         """
83.         noise = random.uniform(-0.02, 0.02)
84.         
85.         influence = 0.0
86. 
87.         if self.type == 'ph_meter':
88.  
89.             acid_pwr = actuators.get('dispenser_acid', 0)
90.             alkali_pwr = actuators.get('dispenser_alkali', 0)
91.             
92.       
93.             influence = (alkali_pwr * 0.002) - (acid_pwr * 0.002)
94. 
95.             natural_drift = 0.0005 
96.             self.value += influence + natural_drift + noise
97. 
98.         elif self.type == 'do_meter':
99.             aerator_pwr = actuators.get('aerator', 0)
100.    
101.             consumption = 0.03 
102.      
103.             recovery = (aerator_pwr / 100.0) * 0.15 
104.             
105.             self.value += recovery - consumption + noise
106.             self.value = max(0, min(14, self.value))
107. 
108.   
109.         elif self.type == 'level_sensor':
110.             pump_pwr = actuators.get('pump', 0)
111.             valve_pwr = actuators.get('valve', 0) 
112.     
113.             inflow = (valve_pwr / 100.0) * 1.0  
114.             outflow = (pump_pwr / 100.0) * 1.2 
115.             
116.             self.value += inflow - outflow + noise
117.             self.value = max(0, min(100, self.value))
118. 
119.         elif self.type == 'orp_meter':
120.             chlorine_pwr = actuators.get('dispenser_chlorine', 0)
121.          
122.             decay = 1.5 
123.             boost = (chlorine_pwr / 100.0) * 5.0
124.             
125.             self.value += boost - decay + noise
126. 
127.      
128.         elif self.type == 'pressure_sensor':
129. 
130.             pump_pwr = actuators.get('pump', 0)
131.             filter_pwr = actuators.get('filter', 0) 
132.             
133.             base_pressure = 2.0 
134.             pump_effect = (pump_pwr / 100.0) * 2.5
135. 
136.             filter_drop = (filter_pwr / 100.0) * 3.0
137.        
138.             clogging = 0.005 
139.             
140.             target = base_pressure + pump_effect - filter_drop
141.   
142.             self.value = (self.value * 0.9) + (target * 0.1) + clogging + noise
143. 
144.      
145.         elif self.type == 'thermometer':
146.   
147.             ambient_temp = 19.5 
148.  
149.             pump_heat = actuators.get('pump', 0) * 0.0001
150.             
151.             diff = ambient_temp - self.value
152.             self.value += (diff * 0.01) + pump_heat + noise
153. 
154.         elif self.type == 'turbidity_meter':
155.             filter_pwr = actuators.get('filter', 0)
156.   
157.             cleaning = (filter_pwr / 100.0) * 0.1
158.             dirt_accumulation = 0.01
159.             
160.             self.value += dirt_accumulation - cleaning + noise
161.             self.value = max(0, self.value)
162. 
163.         else:
164.             self.value += noise
165. 
166.     def get_reading(self):
167.         """
168.         РОЗУМНА ОБРОБКА ДАНИХ
169.         1. Перевіряє на аномалії (Z-Score).
170.         2. Якщо аномалія -> повертає середнє (фільтрує).
171.         3. Якщо норма -> повертає сире значення (без згладжування).
172.         """
173.         data = TelemetryStorage.load_all()
174.         history = data.get(self.id, [])
175. 
176.         if len(history) < 3:
177.             TelemetryStorage.save_reading(self.id, self.value)
178.             return round(self.value, 2)
179. 
180.     
181.         mean = sum(history) / len(history)
182.         variance = sum([((x - mean) ** 2) for x in history]) / len(history)
183.         std_dev = variance ** 0.5
184. 
185.         z_score_threshold = 4
186.         is_anomaly = False
187.         
188.         effective_std_dev = max(std_dev, 0.05) 
189.         z_score = abs(self.value - mean) / effective_std_dev
190.         if z_score > z_score_threshold:
191.             is_anomaly = True
192.             print(f" [Sensor {self.type}] Anomaly detected! Val: {self.value:.2f}, Mean: {mean:.2f} (Z-Score: {z_score:.2f})")
193. 
194.         final_value = mean if is_anomaly else self.value
195. 
196.         TelemetryStorage.save_reading(self.id, final_value)
197. 
198.         return round(final_value, 2)
199. 
200. class IoTDevice:
201.     def __init__(self):
202.         self.token = None
203.         self.sensors = []
204.         self.actuators_state = {} 
205.         self.mqtt_client = mqtt.Client()
206. 
207.     def login(self):
208.         print(f" Logging in as {USER_EMAIL}...")
209.         try:
210.             res = requests.post(f"{API_URL}/auth/login", json={"email": USER_EMAIL, "password": USER_PASS})
211.             res.raise_for_status()
212.             self.token = res.json()['token']
213.             print(" Login successful.")
214.         except Exception as e:
215.             print(f" Login failed: {e}")
216.             exit(1)
217. 
218.     def init_sensors(self):
219.         print("⚙️ Fetching station config (Sensors)...")
220.         headers = {"Authorization": f"Bearer {self.token}"}
221.         try:
222.        
223.             res = requests.get(f"{API_URL}/telemetry/station/{STATION_ID}/latest", headers=headers)
224.             res.raise_for_status()
225.             data = res.json()
226.             
227.             self.sensors = []
228.             for s in data:
229.                 self.sensors.append(SensorEmulator(s))
230.             print(f" Initialized {len(self.sensors)} sensors from API.")
231.         except Exception as e:
232.             print(f" Config failed: {e}")
233. 
234.     def sync_actuators(self):
235.         """
236.         Зчитує команди для з API
237.         """
238.         headers = {"Authorization": f"Bearer {self.token}"}
239.         try:
240.             res = requests.get(f"{API_URL}/actuators/station/{STATION_ID}/latest", headers=headers)
241.             if res.status_code == 200:
242.                 devices = res.json()
243.                 print("\n🔌 Actuator Status (Server Control):")
244.                 
245.                 if not devices:
246.                     print(f"   Жодних контролерів не знайдено для станції {STATION_ID}")
247.                     print("     Перевірте ID станції в .env або seed-дані в БД.")
248.                 
249.                 for dev in devices:
250.  
251.                     pct = float(dev.get('activationPercentage') or 0)
252.   
253.                     self.actuators_state[dev['type']] = pct
254.      
255.                     status_symbol = "" if pct > 0 else ""
256.                     print(f"   {status_symbol} {dev['name']} ({dev['type']}): {pct}%")
257.         except Exception as e:
258.             print(f" Actuator sync failed: {e}")
259. 
260.     def run(self):
261.         print(f" Connecting to MQTT: {MQTT_BROKER}...")
262.         try:
263.             self.mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
264.             self.mqtt_client.loop_start()
265.         except Exception as e:
266.             print(f" MQTT Connection failed: {e}")
267.             return
268. 
269.         print(" Simulation started...")
270.         
271.         try:
272.             while True:
273.                 self.sync_actuators()
274. 
275.                 print("\n📊 Sensor Data (Sending to MQTT):")
276.                 for sensor in self.sensors:
277.   
278.                     sensor.update_physics(self.actuators_state)
279.  
280.                    
281.                     # if random.random() < 0.05:
282.                       
283.                     #     spike = random.uniform(15.0, 35.0) * random.choice([-1, 1])
284.                     #     print(f" [TEST] Injecting ANOMALY for {sensor.type}: {spike:+.2f}")
285.                     #     sensor.value += spike
286.                     
287. 
288.                     val = sensor.get_reading()
289. 
290.                     payload = {
291.                         "sensorId": sensor.id,
292.                         "value": val,
293.                         "measuredAt": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
294.                     }
295.                     
296.       
297.                     topic = f"station/{STATION_ID}/telemetry"
298.                     self.mqtt_client.publish(topic, json.dumps(payload))
299.                     print(f"   -> {sensor.type}: {val}")
300. 
301.                 time.sleep(5)
302. 
303.         except KeyboardInterrupt:
304.             self.mqtt_client.disconnect()
305.             print("\n Simulation stopped.")
306. 
307. if __name__ == "__main__":
308.     device = IoTDevice()
309.     device.login()
310.     device.init_sensors()
311.     device.run()

Mqtt-Bridge.js
1. import mqtt from 'mqtt';
2. import axios from 'axios';
3. import dotenv from 'dotenv';
4. 
5. dotenv.config();
6. 
7. 
8. const MQTT_BROKER = process.env.MQTT_BROKER || 'mqtt://test.mosquitto.org';
9. const API_URL = process.env.API_URL || 'http://localhost:4001';
10. 
11. 
12. const BRIDGE_USER = {
13.   email: process.env.BRIDGE_EMAIL || "user@example.com",
14.   password: process.env.BRIDGE_PASSWORD || "string",
15.   fullName: "System MQTT Bridge",
16.   role: "admin" 
17. };
18. 
19. let authToken: string | null = null;
20. 
21. // --- ФУНКЦІЯ АВТОРИЗАЦІЇ ---
22. async function authenticate() {
23.   console.log(' Bridge Authenticating...');
24.   
25.   try {
26.     const loginRes = await axios.post(`${API_URL}/auth/login`, {
27.       email: BRIDGE_USER.email,
28.       password: BRIDGE_USER.password
29.     });
30.     
31.     authToken = loginRes.data.token;
32.     console.log(' Login successful. Token acquired.');
33. 
34.   } catch (error: any) {
35.     if (error.response && (error.response.status === 401 || error.response.status === 400)) {
36.       console.log(' User not found or invalid credentials. Attempting registration...');
37.       
38.       try {
39.         await axios.post(`${API_URL}/auth/register`, BRIDGE_USER);
40.         console.log(' Registration successful. Retrying login...');
41.        
42.         const retryLogin = await axios.post(`${API_URL}/auth/login`, {
43.           email: BRIDGE_USER.email,
44.           password: BRIDGE_USER.password
45.         });
46.         authToken = retryLogin.data.token;
47.         console.log(' Login successful after registration.');
48.         
49.       } catch (regError: any) {
50.         console.error(' FATAL: Could not register Bridge user:', regError.response?.data || regError.message);
51.         process.exit(1);
52.       }
53.     } else {
54.       console.error(' FATAL: API is unreachable:', error.message);
55.       setTimeout(authenticate, 5000);
56.     }
57.   }
58. }
59. 
60. 
61. (async () => {
62. 
63.   await authenticate();
64. 
65.   if (!authToken) return;
66. 
67.   console.log(`🔌 Connecting to MQTT Broker: ${MQTT_BROKER}`);
68.   const client = mqtt.connect(MQTT_BROKER);
69. 
70.   client.on('connect', () => {
71.     console.log(' MQTT Connected');
72.     client.subscribe('station/+/telemetry', (err) => {
73.       if (!err) console.log('📡 Subscribed to station/+/telemetry');
74.     });
75.   });
76. 
77.   client.on('message', async (topic, message) => {
78.     if (!authToken) {
79.       console.warn(' No token available. Skipping message.');
80.       return;
81.     }
82. 
83.     try {
84.       const payload = JSON.parse(message.toString());
85.       if (payload.measuredAt && typeof payload.measuredAt === 'string') {
86.         if (!payload.measuredAt.endsWith('Z') && !payload.measuredAt.includes('+')) {
87.           payload.measuredAt = payload.measuredAt + 'Z';
88.         }
89.       }
90.       await axios.post(`${API_URL}/telemetry`, payload, {
91.         headers: {
92.           'Authorization': `Bearer ${authToken}`,
93.           'Content-Type': 'application/json'
94.         }
95.       });
96. 
97.       process.stdout.write('S'); 
98. 
99.     } catch (error: any) {
100.       process.stdout.write('E');
101.      
102.       if (error.response && (error.response.status === 401 || error.response.status === 403)) {
103.         console.log('\n Token expired. Re-authenticating...');
104.         await authenticate();
105.       } else {
106.         console.error('\n API Error:', error.response?.data || error.message);
107.       }
108.     }
109.   });
110. 
111.   client.on('error', (err) => {
112.     console.error('\n MQTT Error:', err);
113.   });
114. })();

2


